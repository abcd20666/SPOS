
// Simple FIFO Page Replacement Algorithm
import java.util.*;

    class FIFO {
    public static void main(String[] args) {
        int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1};
        int n = pages.length;     // Total number of pages
        int frames = 3;           // Number of available frames
        int temp[] = new int[frames];
        int pageFaults = 0;
        int next = 0;             // Points to the frame to replace next (FIFO order)

        // Initially, all frames are empty
        for (int i = 0; i < frames; i++)
            temp[i] = -1;

        System.out.println("Page\tFrame 1\tFrame 2\tFrame 3");

        // Traverse each page one by one
        for (int i = 0; i < n; i++) {
            int page = pages[i];
            boolean found = false;

            // Check if page already exists in any frame
            for (int j = 0; j < frames; j++) {
                if (temp[j] == page) {
                    found = true;
                    break;
                }
            }

            // If page not found (page fault)
            if (!found) {
                temp[next] = page;        // Replace page using FIFO order
                next = (next + 1) % frames; // Move pointer to next frame
                pageFaults++;
            }

            // Print current frame status
            System.out.print(page + "\t");
            for (int j = 0; j < frames; j++) {
                if (temp[j] != -1)
                    System.out.print(temp[j] + "\t");
                else
                    System.out.print("-\t");
            }
            System.out.println();
        }

        System.out.println("\nTotal Page Faults: " + pageFaults);
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





// Simple LRU (Least Recently Used) Page Replacement Algorithm
import java.util.*;

class LRU {
    public static void main(String[] args) {
        int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1};
        int n = pages.length;    // Total number of pages
        int frames = 3;          // Number of available frames
        ArrayList<Integer> memory = new ArrayList<>();
        int pageFaults = 0;

        System.out.println("Page\tFrame 1\tFrame 2\tFrame 3");

        // Go through each page one by one
        for (int i = 0; i < n; i++) {
            int page = pages[i];

            // If page is already in memory, remove it (to update its recent use)
            if (memory.contains(page)) {
                memory.remove(Integer.valueOf(page));
            } 
            // If memory is full and page not found, remove least recently used page
            else if (memory.size() == frames) {
                memory.remove(0);   // remove first page (oldest one)
                pageFaults++;
            } 
            // If page not found but there is space
            else {
                pageFaults++;
            }

            // Add the current page (most recently used)
            memory.add(page);

            // Print current frame contents
            System.out.print(page + "\t");
            for (int j = 0; j < frames; j++) {
                if (j < memory.size())
                    System.out.print(memory.get(j) + "\t");
                else
                    System.out.print("-\t");
            }
            System.out.println();
        }

        System.out.println("\nTotal Page Faults: " + pageFaults);
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

import java.util.*;

public class SimpleOptimal {
    public static void main(String[] args) {
        int pages[] = {7, 0, 1, 2, 0, 3};
        int n = pages.length;
        int frames = 3;
        ArrayList<Integer> memory = new ArrayList<>();
        int pageFaults = 0;

        System.out.println("Page\tFrames");

        for (int i = 0; i < n; i++) {
            int page = pages[i];

            // If page already exists, skip
            if (memory.contains(page)) {
                // no page fault
            } else {
                // Page fault occurs
                pageFaults++;

                if (memory.size() < frames) {
                    // Empty frame available
                    memory.add(page);
                } else {
                    // Need to replace one page
                    int farthest = -1, indexToReplace = -1;

                    // Find the page which will not be used for the longest time
                    for (int j = 0; j < memory.size(); j++) {
                        int nextUse = Integer.MAX_VALUE;
                        for (int k = i + 1; k < n; k++) {
                            if (memory.get(j) == pages[k]) {
                                nextUse = k;
                                break;
                            }
                        }
                        if (nextUse > farthest) {
                            farthest = nextUse;
                            indexToReplace = j;
                        }
                    }
                    memory.set(indexToReplace, page);
                }
            }

            // Print current memory state
            System.out.print(page + "\t");
            for (int p : memory) System.out.print(p + " ");
            System.out.println();
        }

        System.out.println("\nTotal Page Faults: " + pageFaults);
    }
}